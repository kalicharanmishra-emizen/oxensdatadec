"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const BaseAPIClient_1 = require("./internals/BaseAPIClient");
const utils_1 = require("./internals/utils");
class AccountingAPIClient extends BaseAPIClient_1.BaseAPIClient {
    constructor(options, authState, _oAuth1HttpClient) {
        super(options, authState, { apiBasePath: '/api.xro/2.0/' }, _oAuth1HttpClient);
        this.accounts = {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'accounts';
                if (args && args.AccountID) {
                    endpoint = endpoint + '/' + args.AccountID;
                    delete args.AccountID; // remove from query string
                }
                const header = this.generateHeader(args);
                endpoint += utils_1.generateQueryString(args);
                return this.oauth1Client.get(endpoint, header);
            }),
            create: (account) => __awaiter(this, void 0, void 0, function* () {
                // from docs: You can only add accounts one at a time (i.e. you'll need to do multiple API calls to add many accounts)
                const endpoint = 'accounts';
                return this.oauth1Client.put(endpoint, account);
            }),
            update: (account, args) => __awaiter(this, void 0, void 0, function* () {
                // from docs: You can only update accounts one at a time (i.e. youâ€™ll need to do multiple API calls to update many accounts)
                let endpoint = 'accounts';
                if (args && args.AccountID) {
                    endpoint = endpoint + '/' + args.AccountID;
                    delete args.AccountID; // remove from query string
                }
                endpoint += utils_1.generateQueryString(args);
                return this.oauth1Client.post(endpoint, account);
            }),
            delete: (args) => __awaiter(this, void 0, void 0, function* () {
                // from docs: If an account is not able to be deleted (e.g. ssystem accounts and accounts used on transactions) you can update the status to ARCHIVED.
                const endpoint = 'accounts/' + args.AccountID;
                return this.oauth1Client.delete(endpoint);
            }),
            attachments: this.generateAttachmentsEndpoint('accounts')
        };
        this.bankTransactions = {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'banktransactions';
                if (args && args.BankTransactionID) {
                    endpoint = endpoint + '/' + args.BankTransactionID;
                    delete args.BankTransactionID; // remove from query string
                }
                const header = this.generateHeader(args);
                endpoint += utils_1.generateQueryString(args);
                return this.oauth1Client.get(endpoint, header);
            }),
            create: (bankTransaction, args) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = 'banktransactions' + utils_1.generateQueryString(args, true);
                return this.oauth1Client.put(endpoint, bankTransaction);
            }),
            update: (bankTransaction, args) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = 'banktransactions' + utils_1.generateQueryString(args, true);
                return this.oauth1Client.post(endpoint, bankTransaction);
            }),
            attachments: this.generateAttachmentsEndpoint('banktransactions'),
            history: this.generateHistoryEndpoint('banktransactions', 'BankTransactionID')
        };
        this.bankTransfers = {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'banktransfers';
                if (args && args.BankTransferID) {
                    endpoint = endpoint + '/' + args.BankTransferID;
                    delete args.BankTransferID;
                }
                endpoint += utils_1.generateQueryString(args);
                return this.oauth1Client.get(endpoint, this.generateHeader(args));
            }),
            create: (bankTransfers, args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'banktransfers';
                endpoint += utils_1.generateQueryString(args, true);
                return this.oauth1Client.put(endpoint, bankTransfers);
            }),
            attachments: this.generateAttachmentsEndpoint('banktransfers'),
            history: this.generateHistoryEndpoint('banktransfers', 'BankTransferID')
        };
        this.brandingThemes = {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'brandingthemes';
                if (args && args.BrandingThemeID) {
                    endpoint = endpoint + '/' + args.BrandingThemeID;
                    delete args.BrandingThemeID;
                }
                return this.oauth1Client.get(endpoint);
            })
        };
        this.contactGroups = {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'contactgroups';
                if (args && args.ContactGroupID) {
                    endpoint = endpoint + '/' + args.ContactGroupID;
                    delete args.ContactGroupID;
                }
                endpoint += utils_1.generateQueryString(args);
                return this.oauth1Client.get(endpoint);
            }),
            create: (contactGroups, args) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = 'contactgroups' + utils_1.generateQueryString(args, true);
                return this.oauth1Client.put(endpoint, contactGroups);
            }),
            update: (contactGroups, args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'contactgroups';
                if (args && args.ContactGroupID) {
                    endpoint = endpoint + '/' + args.ContactGroupID;
                    delete args.ContactGroupID;
                }
                endpoint += utils_1.generateQueryString(args, true);
                return this.oauth1Client.post(endpoint, contactGroups);
            }),
            contacts: {
                delete: (args) => __awaiter(this, void 0, void 0, function* () {
                    let endpoint = 'contactgroups';
                    if (args && args.ContactGroupID) {
                        endpoint = endpoint + '/' + args.ContactGroupID + '/contacts';
                        delete args.ContactGroupID;
                        if (args.ContactID) {
                            endpoint = endpoint + '/' + args.ContactID;
                            delete args.ContactID;
                        }
                    }
                    endpoint += utils_1.generateQueryString(args, true);
                    return this.oauth1Client.delete(endpoint);
                }),
                create: (contact, args) => __awaiter(this, void 0, void 0, function* () {
                    let endpoint = 'contactgroups';
                    if (args && args.ContactGroupID) {
                        endpoint = endpoint + '/' + args.ContactGroupID + '/contacts';
                        delete args.ContactGroupID;
                    }
                    endpoint += utils_1.generateQueryString(args, true);
                    return this.oauth1Client.put(endpoint, contact);
                })
            }
        };
        this.contacts = {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'contacts';
                if (args && args.ContactID) {
                    endpoint = endpoint + '/' + args.ContactID;
                    delete args.ContactID;
                }
                const header = this.generateHeader(args);
                endpoint += utils_1.generateQueryString(args);
                return this.oauth1Client.get(endpoint, header);
            }),
            create: (body, args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'contacts';
                endpoint += utils_1.generateQueryString(args, true);
                return this.oauth1Client.put(endpoint, body);
            }),
            update: (body, args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'contacts';
                if (args && args.ContactID) {
                    endpoint = endpoint + '/' + args.ContactID;
                    delete args.ContactID;
                }
                endpoint += utils_1.generateQueryString(args, true);
                return this.oauth1Client.post(endpoint, body);
            }),
            CISsettings: {
                get: (args) => __awaiter(this, void 0, void 0, function* () {
                    let endpoint = 'contacts';
                    if (args && args.ContactID) {
                        endpoint = endpoint + '/' + args.ContactID;
                        delete args.ContactID;
                    }
                    endpoint += '/cissettings';
                    return this.oauth1Client.get(endpoint);
                })
            },
            attachments: this.generateAttachmentsEndpoint('contacts'),
            history: this.generateHistoryEndpoint('contacts', 'ContactID')
        };
        this.creditNotes = {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'creditnotes';
                if (args && args.CreditNoteID) {
                    endpoint = endpoint + '/' + args.CreditNoteID;
                    delete args.CreditNoteID; // remove from query string
                }
                else if (args && args.CreditNoteNumber) {
                    endpoint = endpoint + '/' + encodeURIComponent(args.CreditNoteNumber);
                    delete args.CreditNoteNumber;
                }
                const header = this.generateHeader(args);
                endpoint += utils_1.generateQueryString(args);
                return this.oauth1Client.get(endpoint, header);
            }),
            savePDF: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'creditnotes';
                if (args && args.CreditNoteID) {
                    endpoint = endpoint + '/' + args.CreditNoteID;
                    delete args.CreditNoteID;
                }
                endpoint += utils_1.generateQueryString(args);
                const writeStream = fs.createWriteStream(args.savePath);
                return this.oauth1Client.writeUTF8ResponseToStream(endpoint, 'application/pdf', writeStream);
            }),
            create: (creditNote, args) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = 'creditnotes' + utils_1.generateQueryString(args, true);
                return this.oauth1Client.put(endpoint, creditNote);
            }),
            update: (creditNote, args) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = 'creditnotes' + utils_1.generateQueryString(args, true);
                return this.oauth1Client.post(endpoint, creditNote);
            }),
            allocations: {
                create: (allocation, args) => __awaiter(this, void 0, void 0, function* () {
                    let endpoint = 'creditnotes';
                    if (args && args.CreditNoteID) {
                        endpoint = endpoint + '/' + args.CreditNoteID;
                        delete args.CreditNoteID; // remove from query string
                    }
                    endpoint += '/allocations';
                    endpoint += utils_1.generateQueryString(args);
                    return this.oauth1Client.put(endpoint, allocation);
                }),
            },
            attachments: this.generateAttachmentsEndpoint('creditnotes'),
            history: this.generateHistoryEndpoint('creditnotes', 'CreditNoteID')
        };
        this.currencies = {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = 'currencies' + utils_1.generateQueryString(args);
                return this.oauth1Client.get(endpoint);
            }),
            create: (currency) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = 'currencies';
                return this.oauth1Client.put(endpoint, currency);
            })
        };
        this.employees = {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'employees';
                if (args && args.EmployeeID) {
                    endpoint = endpoint + '/' + args.EmployeeID;
                    delete args.EmployeeID;
                }
                const header = this.generateHeader(args);
                endpoint += utils_1.generateQueryString(args);
                return this.oauth1Client.get(endpoint, header);
            }),
            create: (employees) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = 'employees';
                return this.oauth1Client.put(endpoint, employees);
            }),
            update: (employees) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = 'employees';
                return this.oauth1Client.post(endpoint, employees);
            })
        };
        this.expenseClaims = {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'expenseclaims';
                if (args && args.ExpenseClaimID) {
                    endpoint = endpoint + '/' + args.ExpenseClaimID;
                    delete args.ExpenseClaimID;
                }
                endpoint += utils_1.generateQueryString(args);
                return this.oauth1Client.get(endpoint);
            }),
            create: (expenseClaims, args) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = 'expenseclaims' + utils_1.generateQueryString(args, true);
                return this.oauth1Client.put(endpoint, expenseClaims);
            }),
            update: (expenseClaims, args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'expenseclaims';
                if (args && args.ExpenseClaimID) {
                    endpoint = endpoint + '/' + args.ExpenseClaimID;
                    delete args.ExpenseClaimID;
                }
                endpoint += utils_1.generateQueryString(args, true);
                return this.oauth1Client.post(endpoint, expenseClaims);
            }),
            history: this.generateHistoryEndpoint('expenseclaims', 'ExpenseClaimID')
        };
        this.invoiceReminders = {
            get: () => __awaiter(this, void 0, void 0, function* () {
                const endpoint = 'invoicereminders/settings';
                return this.oauth1Client.get(endpoint);
            })
        };
        this.invoices = {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'invoices';
                if (args && args.InvoiceID) {
                    endpoint = endpoint + '/' + args.InvoiceID;
                    delete args.InvoiceID;
                }
                else if (args && args.InvoiceNumber) {
                    endpoint = endpoint + '/' + encodeURIComponent(args.InvoiceNumber);
                    delete args.InvoiceNumber;
                }
                const header = this.generateHeader(args);
                endpoint += utils_1.generateQueryString(args);
                return this.oauth1Client.get(endpoint, header);
            }),
            savePDF: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'invoices';
                if (args && args.InvoiceID) {
                    endpoint = endpoint + '/' + args.InvoiceID;
                    delete args.InvoiceID;
                }
                else if (args && args.InvoiceNumber) {
                    endpoint = endpoint + '/' + encodeURIComponent(args.InvoiceNumber);
                    delete args.InvoiceNumber;
                }
                endpoint += utils_1.generateQueryString(args);
                const writeStream = fs.createWriteStream(args.savePath);
                return this.oauth1Client.writeUTF8ResponseToStream(endpoint, 'application/pdf', writeStream);
            }),
            create: (invoice, args) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = 'invoices' + utils_1.generateQueryString(args, true);
                return this.oauth1Client.put(endpoint, invoice);
            }),
            update: (invoices, args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'invoices';
                if (args && args.InvoiceID) {
                    endpoint = endpoint + '/' + args.InvoiceID;
                    delete args.InvoiceID;
                }
                else if (args && args.InvoiceNumber) {
                    endpoint = endpoint + '/' + encodeURIComponent(args.InvoiceNumber);
                    delete args.InvoiceNumber;
                }
                endpoint += utils_1.generateQueryString(args, true);
                return this.oauth1Client.post(endpoint, invoices);
            }),
            onlineInvoice: {
                get: (args) => __awaiter(this, void 0, void 0, function* () {
                    let endpoint = 'invoices';
                    if (args && args.InvoiceID) {
                        endpoint = endpoint + '/' + args.InvoiceID;
                        delete args.InvoiceID;
                    }
                    endpoint += '/onlineinvoice';
                    return this.oauth1Client.get(endpoint);
                })
            },
            attachments: this.generateAttachmentsEndpoint('invoices'),
            history: this.generateHistoryEndpoint('invoices', 'InvoiceID'),
            email: {
                create: (args) => __awaiter(this, void 0, void 0, function* () {
                    let endpoint = 'invoices';
                    if (args && args.InvoiceID) {
                        endpoint = endpoint + '/' + args.InvoiceID;
                        delete args.InvoiceID;
                    }
                    endpoint += '/email';
                    return this.oauth1Client.post(endpoint, {});
                })
            }
        };
        this.repeatingInvoices = {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'repeatinginvoices';
                if (args && args.RepeatingInvoiceID) {
                    endpoint = endpoint + '/' + args.RepeatingInvoiceID;
                    delete args.RepeatingInvoiceID;
                }
                const headers = this.generateHeader(args);
                endpoint += utils_1.generateQueryString(args);
                return this.oauth1Client.get(endpoint, headers);
            }),
            attachments: this.generateAttachmentsEndpoint('repeatinginvoices'),
            history: this.generateHistoryEndpoint('repeatinginvoices', 'RepeatingInvoiceID')
        };
        this.items = {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'items';
                if (args && args.ItemID) {
                    endpoint = endpoint + '/' + args.ItemID;
                    delete args.ItemID;
                }
                else if (args && args.Code) {
                    endpoint = endpoint + '/' + encodeURIComponent(args.Code);
                    delete args.Code;
                }
                const headers = this.generateHeader(args);
                endpoint += utils_1.generateQueryString(args);
                return this.oauth1Client.get(endpoint, headers);
            }),
            create: (items, args) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = 'items' + utils_1.generateQueryString(args, true);
                return this.oauth1Client.put(endpoint, items);
            }),
            update: (items, args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'items';
                if (args && args.ItemID) {
                    endpoint = endpoint + '/' + args.ItemID;
                    delete args.ItemID;
                }
                endpoint += utils_1.generateQueryString(args, true);
                return this.oauth1Client.post(endpoint, items);
            }),
            delete: (args) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = 'items' + '/' + args.ItemID;
                return this.oauth1Client.delete(endpoint);
            }),
            history: this.generateHistoryEndpoint('items', 'ItemID')
        };
        this.journals = {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'journals';
                if (args && args.Recordfilter) {
                    endpoint = endpoint + '/' + encodeURIComponent(args.Recordfilter);
                    delete args.Recordfilter;
                }
                const headers = this.generateHeader(args);
                endpoint += utils_1.generateQueryString(args);
                return this.oauth1Client.get(endpoint, headers);
            })
        };
        this.linkedTransactions = {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'linkedtransactions';
                if (args && args.LinkedTransactionID) {
                    endpoint = endpoint + '/' + args.LinkedTransactionID;
                    delete args.LinkedTransactionID; // remove from query string
                }
                const header = this.generateHeader(args);
                endpoint += utils_1.generateQueryString(args);
                return this.oauth1Client.get(endpoint, header);
            }),
            create: (linkedTransaction, args) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = 'linkedtransactions' + utils_1.generateQueryString(args, true);
                return this.oauth1Client.put(endpoint, linkedTransaction);
            }),
            update: (linkedTransaction, args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'linkedtransactions';
                if (args && args.LinkedTransactionID) {
                    endpoint = endpoint + '/' + args.LinkedTransactionID;
                    delete args.LinkedTransactionID; // remove from query string
                }
                endpoint += utils_1.generateQueryString(args, true);
                return this.oauth1Client.post(endpoint, linkedTransaction);
            }),
            delete: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'linkedtransactions';
                if (args && args.LinkedTransactionID) {
                    endpoint = endpoint + '/' + args.LinkedTransactionID;
                    delete args.LinkedTransactionID; // remove from query string
                }
                endpoint += utils_1.generateQueryString(args, false);
                return this.oauth1Client.delete(endpoint);
            }),
        };
        this.manualJournals = {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'manualjournals';
                if (args && args.ManualJournalID) {
                    endpoint += '/' + args.ManualJournalID;
                    delete args.ManualJournalID;
                }
                const header = this.generateHeader(args);
                endpoint += utils_1.generateQueryString(args);
                return this.oauth1Client.get(endpoint, header);
            }),
            create: (manualJournals, args) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = 'manualjournals' + utils_1.generateQueryString(args, true);
                return this.oauth1Client.put(endpoint, manualJournals);
            }),
            update: (manualJournals, args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'manualjournals';
                if (args && args.ManualJournalID) {
                    endpoint += '/' + args.ManualJournalID;
                    delete args.ManualJournalID;
                }
                endpoint += utils_1.generateQueryString(args, true);
                return this.oauth1Client.post(endpoint, manualJournals);
            }),
            attachments: this.generateAttachmentsEndpoint('manualjournals')
        };
        this.organisations = {
            get: () => __awaiter(this, void 0, void 0, function* () {
                const endpoint = 'organisations';
                return this.oauth1Client.get(endpoint);
            }),
            CISSettings: {
                get: (args) => __awaiter(this, void 0, void 0, function* () {
                    let endpoint = 'organisations';
                    if (args && args.OrganisationID) {
                        endpoint = endpoint + '/' + args.OrganisationID + '/CISSettings';
                        delete args.OrganisationID;
                    }
                    endpoint += utils_1.generateQueryString(args);
                    return this.oauth1Client.get(endpoint);
                })
            }
        };
        this.overpayments = {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'overpayments';
                if (args && args.OverpaymentID) {
                    endpoint += '/' + args.OverpaymentID;
                    delete args.OverpaymentID;
                }
                endpoint += utils_1.generateQueryString(args);
                return this.oauth1Client.get(endpoint);
            }),
            allocations: {
                create: (allocations, args) => __awaiter(this, void 0, void 0, function* () {
                    const endpoint = `overpayments/${args.OverpaymentID}/allocations`;
                    return this.oauth1Client.put(endpoint, allocations);
                })
            },
            history: this.generateHistoryEndpoint('overpayments', 'OverpaymentID')
        };
        this.payments = {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'payments';
                if (args && args.PaymentID) {
                    endpoint = endpoint + '/' + args.PaymentID;
                    delete args.PaymentID;
                }
                const headers = this.generateHeader(args);
                endpoint += utils_1.generateQueryString(args);
                return this.oauth1Client.get(endpoint, headers);
            }),
            create: (payments, args) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = 'payments' + utils_1.generateQueryString(args, true);
                return this.oauth1Client.put(endpoint, payments);
            }),
            update: (payments, args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'payments';
                if (args && args.PaymentID) {
                    endpoint = endpoint + '/' + args.PaymentID;
                    delete args.PaymentID;
                }
                endpoint += utils_1.generateQueryString(args, true);
                return this.oauth1Client.post(endpoint, payments);
            }),
            history: this.generateHistoryEndpoint('payments', 'PaymentID')
        };
        this.paymentServices = {
            get: () => __awaiter(this, void 0, void 0, function* () {
                return this.oauth1Client.get('paymentservices');
            }),
            create: (paymentService, args) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = 'paymentservices' + utils_1.generateQueryString(args, true);
                return this.oauth1Client.put(endpoint, paymentService);
            })
        };
        this.prepayments = {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'prepayments';
                if (args && args.PrepaymentID) {
                    endpoint = endpoint + '/' + args.PrepaymentID;
                    delete args.PrepaymentID;
                }
                const headers = this.generateHeader(args);
                endpoint += utils_1.generateQueryString(args);
                return this.oauth1Client.get(endpoint, headers);
            }),
            allocations: {
                create: (allocations, args) => __awaiter(this, void 0, void 0, function* () {
                    const endpoint = `prepayments/${args.PrepaymentID}/allocations`;
                    delete args.PrepaymentID;
                    return this.oauth1Client.put(endpoint, allocations);
                })
            },
            attachments: this.generateAttachmentsEndpoint('prepayments'),
            history: this.generateHistoryEndpoint('prepayments', 'PrepaymentID')
        };
        this.purchaseOrders = {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'purchaseorders';
                if (args && args.PurchaseOrderID) {
                    endpoint = endpoint + '/' + args.PurchaseOrderID;
                    delete args.PurchaseOrderID;
                }
                else if (args && args.PurchaseOrderNumber) {
                    endpoint = endpoint + '/' + encodeURIComponent(args.PurchaseOrderNumber);
                    delete args.PurchaseOrderNumber;
                }
                const headers = this.generateHeader(args);
                endpoint += utils_1.generateQueryString(args);
                return this.oauth1Client.get(endpoint, headers);
            }),
            savePDF: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'purchaseorders';
                if (args && args.PurchaseOrderID) {
                    endpoint = endpoint + '/' + args.PurchaseOrderID;
                    delete args.PurchaseOrderID;
                }
                else if (args && args.PurchaseOrderNumber) {
                    endpoint = endpoint + '/' + encodeURIComponent(args.PurchaseOrderNumber);
                    delete args.PurchaseOrderNumber;
                }
                endpoint += utils_1.generateQueryString(args);
                const writeStream = fs.createWriteStream(args.savePath);
                return this.oauth1Client.writeUTF8ResponseToStream(endpoint, 'application/pdf', writeStream);
            }),
            create: (purchaseOrders, args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'purchaseorders';
                endpoint += utils_1.generateQueryString(args, true);
                return this.oauth1Client.put(endpoint, purchaseOrders);
            }),
            update: (purchaseOrders, args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'purchaseorders';
                if (args && args.PurchaseOrderID) {
                    endpoint = endpoint + '/' + args.PurchaseOrderID;
                    delete args.PurchaseOrderID;
                }
                endpoint += utils_1.generateQueryString(args, true);
                return this.oauth1Client.post(endpoint, purchaseOrders);
            }),
            history: this.generateHistoryEndpoint('purchaseorders', 'PurchaseOrderID')
        };
        this.receipts = {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'receipts';
                if (args && args.ReceiptID) {
                    endpoint += '/' + args.ReceiptID;
                    delete args.ReceiptID;
                }
                const header = this.generateHeader(args);
                endpoint += utils_1.generateQueryString(args);
                return this.oauth1Client.get(endpoint, header);
            }),
            create: (receipts, args) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = 'receipts' + utils_1.generateQueryString(args, true);
                return this.oauth1Client.put(endpoint, receipts);
            }),
            update: (receipts, args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'receipts';
                if (args && args.ReceiptID) {
                    endpoint += '/' + args.ReceiptID;
                    delete args.ReceiptID;
                }
                endpoint += utils_1.generateQueryString(args, true);
                return this.oauth1Client.post(endpoint, receipts);
            }),
            attachments: this.generateAttachmentsEndpoint('receipts'),
            history: this.generateHistoryEndpoint('receipts', 'ReceiptID')
        };
        this.reports = {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'reports';
                if (args) {
                    const reportId = args.ReportID;
                    delete args.ReportID; // remove from querystring
                    endpoint = endpoint + '/' + reportId + utils_1.generateQueryString(args);
                }
                return this.oauth1Client.get(endpoint);
            })
        };
        this.taxRates = {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'taxrates';
                if (args && args.TaxType) {
                    endpoint += '/' + args.TaxType;
                    delete args.TaxType;
                }
                endpoint += utils_1.generateQueryString(args);
                return this.oauth1Client.get(endpoint);
            }),
            create: (body) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = 'taxrates';
                return this.oauth1Client.put(endpoint, body);
            }),
            update: (body) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = 'taxrates';
                return this.oauth1Client.post(endpoint, body);
            })
        };
        this.trackingCategories = {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                // TODO: Support for where arg
                let endpoint = 'trackingcategories';
                if (args && args.TrackingCategoryID) {
                    endpoint = endpoint + '/' + args.TrackingCategoryID;
                }
                const headers = this.generateHeader(args);
                endpoint += utils_1.generateQueryString(args);
                return this.oauth1Client.get(endpoint, headers);
            }),
            create: (trackingCategory) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = 'trackingcategories';
                return this.oauth1Client.put(endpoint, trackingCategory);
            }),
            update: (trackingCategory, args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'trackingcategories';
                if (args && args.TrackingCategoryID) {
                    endpoint = endpoint + '/' + args.TrackingCategoryID;
                    delete args.TrackingCategoryID;
                }
                return this.oauth1Client.post(endpoint, trackingCategory);
            }),
            delete: (args) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = 'trackingcategories/' + args.TrackingCategoryID;
                return this.oauth1Client.delete(endpoint);
            }),
            trackingOptions: {
                create: (trackingOption, args) => __awaiter(this, void 0, void 0, function* () {
                    let endpoint = 'trackingcategories';
                    if (args && args.TrackingCategoryID) {
                        endpoint = endpoint + '/' + args.TrackingCategoryID + '/Options';
                        delete args.TrackingCategoryID;
                    }
                    return this.oauth1Client.put(endpoint, trackingOption);
                }),
                update: (trackingOption, args) => __awaiter(this, void 0, void 0, function* () {
                    let endpoint = 'trackingcategories';
                    if (args && args.TrackingCategoryID && args.TrackingOptionID) {
                        endpoint = endpoint + '/' + args.TrackingCategoryID + '/Options/' + args.TrackingOptionID;
                        delete args.TrackingCategoryID;
                        delete args.TrackingOptionID;
                    }
                    return this.oauth1Client.post(endpoint, trackingOption);
                }),
                delete: (args) => __awaiter(this, void 0, void 0, function* () {
                    const endpoint = 'trackingcategories/' + args.TrackingCategoryID + '/Options/' + args.TrackingOptionID;
                    return this.oauth1Client.delete(endpoint);
                }),
            }
        };
        this.users = {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = 'users';
                if (args && args.UserID) {
                    endpoint = endpoint + '/' + args.UserID;
                    delete args.UserID;
                }
                const headers = this.generateHeader(args);
                endpoint += utils_1.generateQueryString(args);
                return this.oauth1Client.get(endpoint, headers);
            })
        };
    }
    generateAttachmentsEndpoint(path) {
        return {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = `${path}/${args.entityId}/attachments`;
                return this.oauth1Client.get(endpoint);
            }),
            downloadAttachment: (args) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = `${path}/${args.entityId}/attachments/${utils_1.escapeString(args.fileName)}`;
                const writeStream = fs.createWriteStream(args.pathToSave);
                yield this.oauth1Client.writeBinaryResponseToStream(endpoint, args.mimeType, writeStream);
            }),
            uploadAttachment: (args) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = `${path}/${args.entityId}/attachments/${utils_1.escapeString(args.fileName)}` + utils_1.generateQueryString({ IncludeOnline: args.includeOnline });
                const readStream = fs.createReadStream(args.pathToUpload);
                const fileSize = fs.statSync(args.pathToUpload).size;
                return this.oauth1Client.readStreamToRequest(endpoint, args.mimeType, fileSize, readStream);
            }),
            uploadAttachmentFromStream: (args) => __awaiter(this, void 0, void 0, function* () {
                const endpoint = `${path}/${args.entityId}/attachments/${utils_1.escapeString(args.fileName)}` + utils_1.generateQueryString({ IncludeOnline: args.includeOnline });
                return this.oauth1Client.readStreamToRequest(endpoint, args.mimeType, args.fileSize, args.readStream);
            }),
        };
    }
    generateHistoryEndpoint(endpointName, argName) {
        return {
            get: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = endpointName;
                if (args && args[argName]) {
                    endpoint = endpoint + '/' + args[argName];
                    delete args[argName];
                }
                endpoint += '/history';
                return this.oauth1Client.get(endpoint);
            }),
            create: (args) => __awaiter(this, void 0, void 0, function* () {
                let endpoint = endpointName;
                if (args && args[argName]) {
                    endpoint = endpoint + '/' + args[argName];
                    delete args[argName];
                }
                endpoint += '/history';
                return this.oauth1Client.put(endpoint, args.HistoryNote);
            })
        };
    }
    generateHeader(args) {
        if (args && args['If-Modified-Since']) {
            const toReturn = {
                'If-Modified-Since': args['If-Modified-Since']
            };
            delete args['If-Modified-Since'];
            return toReturn;
        }
    }
}
exports.AccountingAPIClient = AccountingAPIClient;
//# sourceMappingURL=AccountingAPIClient.js.map