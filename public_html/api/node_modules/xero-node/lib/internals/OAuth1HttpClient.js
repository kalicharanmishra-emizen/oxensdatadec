"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const http = require("http");
const https = require("https");
const oauth_1 = require("oauth");
const querystring = require("querystring");
const URL = require("url");
const XeroError_1 = require("../XeroError");
/** @private */
class OAuth1HttpClient {
    constructor(config, authState, oAuthLibFactory) {
        this.config = config;
        this.oAuthLibFactory = oAuthLibFactory;
        this._state = null;
        this.agent = null;
        this._defaultHeaders = {
            'Accept': 'application/json',
            'User-Agent': this.config.userAgent
        };
        this.getRequestToken = () => __awaiter(this, void 0, void 0, function* () {
            this.resetToDefaultHeaders();
            return new Promise((resolve, reject) => {
                this.oauthLib.getOAuthRequestToken((err, oauth_token, oauth_token_secret, result) => {
                    if (err) {
                        reject(err.statusCode ? new XeroError_1.XeroError(err.statusCode, err.data, null) : err);
                    }
                    else {
                        resolve({
                            oauth_token,
                            oauth_token_secret
                        });
                    }
                });
            });
        });
        this.buildAuthoriseUrl = (requestToken) => {
            return `${this.config.apiBaseUrl}/oauth/Authorize?oauth_token=${requestToken.oauth_token}`;
        };
        this.swapRequestTokenforAccessToken = (requestToken, oauth_verifier) => __awaiter(this, void 0, void 0, function* () {
            this.resetToDefaultHeaders();
            return new Promise((resolve, reject) => {
                this.oauthLib.getOAuthAccessToken(requestToken.oauth_token, requestToken.oauth_token_secret, oauth_verifier, (err, oauth_token, oauth_token_secret, results) => {
                    if (err) {
                        reject(err.statusCode ? new XeroError_1.XeroError(err.statusCode, err.data, null) : err);
                    }
                    else {
                        const currentMilliseconds = new Date().getTime();
                        const expDate = new Date(currentMilliseconds + (results.oauth_expires_in * 1000));
                        const oauthState = {
                            oauth_token: oauth_token,
                            oauth_token_secret: oauth_token_secret,
                            oauth_session_handle: results.oauth_session_handle,
                            oauth_expires_at: expDate
                        };
                        this.setState(oauthState);
                        resolve(oauthState);
                    }
                });
            });
        });
        this.refreshAccessToken = () => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                // We're accessing this "private" method as the lib does not allow refresh with oauth_session_handle.
                this.oauthLib._performSecureRequest(this._state.oauth_token, this._state.oauth_token_secret, 'POST', this.config.apiBaseUrl + this.config.oauthAccessTokenPath, { oauth_session_handle: this._state.oauth_session_handle }, null, null, (err, data, response) => {
                    if (err) {
                        reject(err.statusCode ? new XeroError_1.XeroError(err.statusCode, err.data, response ? response.headers : null) : err);
                    }
                    else {
                        const results = querystring.parse(data);
                        const currentMilliseconds = new Date().getTime();
                        const expDate = new Date(currentMilliseconds + (results.oauth_expires_in * 1000));
                        const oauthState = {
                            oauth_token: results.oauth_token,
                            oauth_token_secret: results.oauth_token_secret,
                            oauth_session_handle: results.oauth_session_handle,
                            oauth_expires_at: expDate
                        };
                        this.setState(oauthState);
                        resolve(oauthState);
                    }
                });
            });
        });
        this.writeUTF8ResponseToStream = (endpoint, mimeType, writeStream) => {
            this.resetToDefaultHeaders();
            return new Promise((resolve, reject) => {
                this.assertAccessTokenIsSet();
                const oauthForPdf = this.oAuthLibFactory(Object.assign({}, this.config, { accept: mimeType }));
                const request = oauthForPdf.get(this.config.apiBaseUrl + this.config.apiBasePath + endpoint, this._state.oauth_token, this._state.oauth_token_secret);
                request.addListener('response', function (response) {
                    response.on('data', function (chunk) {
                        writeStream.write(chunk);
                    });
                    response.on('end', function () {
                        writeStream.end();
                        return resolve();
                    });
                    response.on('close', function () {
                        writeStream.end();
                        return resolve();
                    });
                });
                request.end();
            });
        };
        this.writeBinaryResponseToStream = (endpoint, mimeType, writeStream) => {
            this.resetToDefaultHeaders();
            return new Promise((resolve, reject) => {
                this.assertAccessTokenIsSet();
                const forPDF = this.oAuthLibFactory(Object.assign({}, this.config, { accept: mimeType }));
                this._OURperformSecureRequest(this._state.oauth_token, this._state.oauth_token_secret, 'GET', this.config.apiBaseUrl + this.config.apiBasePath + endpoint, (err, data, httpResponse) => {
                    // data is the body of the response
                    if (err) {
                        reject(err.statusCode ? new XeroError_1.XeroError(err.statusCode, err.data, httpResponse.headers) : err);
                    }
                    else {
                        const buffer = Buffer.from(data, 'binary');
                        writeStream.write(buffer, () => {
                            writeStream.close();
                            return resolve();
                        });
                    }
                }, forPDF);
            });
        };
        this._OURperformSecureRequest = function (oauth_token, oauth_token_secret, method, url, callback, oauthForBinary) {
            // This code was copied out from the lib as it does not support binary downloads.
            const orderedParameters = oauthForBinary._prepareParameters(oauth_token, oauth_token_secret, method, url, null);
            const parsedUrl = URL.parse(url, false);
            if (parsedUrl.protocol == 'http:' && !parsedUrl.port) {
                parsedUrl.port = '80';
            }
            if (parsedUrl.protocol == 'https:' && !parsedUrl.port) {
                parsedUrl.port = '443';
            }
            const headers = {};
            const authorization = oauthForBinary._buildAuthorizationHeaders(orderedParameters);
            headers['Authorization'] = authorization;
            headers['Host'] = parsedUrl.host;
            for (const key in this._headers) {
                if (this._headers.hasOwnProperty(key)) {
                    headers[key] = this._headers[key];
                }
            }
            headers['Content-length'] = 0;
            let path;
            if (!parsedUrl.pathname || parsedUrl.pathname == '') {
                parsedUrl.pathname = '/';
            }
            // tslint:disable-next-line:prefer-conditional-expression
            if (parsedUrl.query) {
                path = parsedUrl.pathname + '?' + parsedUrl.query;
            }
            else {
                path = parsedUrl.pathname;
            }
            let request;
            // tslint:disable-next-line:prefer-conditional-expression
            if (parsedUrl.protocol == 'https:') {
                request = oauthForBinary._createClient(parsedUrl.port, parsedUrl.hostname, method, path, headers, true);
            }
            else {
                request = oauthForBinary._createClient(parsedUrl.port, parsedUrl.hostname, method, path, headers);
            }
            let data = '';
            function passBackControl(response) {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    callback(null, data, response);
                }
                else {
                    callback({ statusCode: response.statusCode, data: data }, data, response);
                }
            }
            request.on('response', function (response) {
                response.setEncoding('binary');
                response.on('data', function (chunk) {
                    data += chunk;
                });
                response.on('end', function () {
                    passBackControl(response);
                });
                // response.on('close', function() {
                //     passBackControl(response);
                // });
            });
            request.on('error', function (err) {
                callback(err);
            });
            request.end();
        };
        this.readStreamToRequest = (endpoint, mimeType, size, readStream) => {
            this.resetToDefaultHeaders();
            return new Promise((resolve, reject) => {
                this.assertAccessTokenIsSet();
                this.resetToDefaultHeaders();
                const bufs = [];
                readStream
                    .on('data', (chunk) => {
                    bufs.push(chunk);
                })
                    .on('end', () => {
                    this.oauthLib._headers = Object.assign({}, this._defaultHeaders, { 'Content-Type': mimeType, 'Content-Length': size });
                    this.oauthLib.post(this.config.apiBaseUrl + this.config.apiBasePath + endpoint, // url
                    this._state.oauth_token, this._state.oauth_token_secret, Buffer.concat(bufs), mimeType, (err, data, httpResponse) => {
                        if (err) {
                            reject(new XeroError_1.XeroError(httpResponse.statusCode, data, httpResponse ? httpResponse.headers : null));
                        }
                        else {
                            const toReturn = JSON.parse(data);
                            return resolve(toReturn);
                        }
                    });
                });
            });
        };
        this.get = (endpoint, customHeaders) => __awaiter(this, void 0, void 0, function* () {
            this.resetToDefaultHeaders();
            this.oauthLib._headers = Object.assign({}, this._defaultHeaders, customHeaders);
            return new Promise((resolve, reject) => {
                this.assertAccessTokenIsSet();
                this.oauthLib.get(this.config.apiBaseUrl + this.config.apiBasePath + endpoint, // url
                this._state.oauth_token, this._state.oauth_token_secret, (err, data, httpResponse) => {
                    // data is the body of the response
                    if (err) {
                        reject(err.statusCode ? new XeroError_1.XeroError(err.statusCode, err.data, httpResponse ? httpResponse.headers : null) : err);
                    }
                    else {
                        const toReturn = JSON.parse(data);
                        return resolve(toReturn);
                    }
                });
            });
        });
        this.put = (endpoint, body, customHeaders) => __awaiter(this, void 0, void 0, function* () {
            this.resetToDefaultHeaders();
            this.oauthLib._headers = Object.assign({}, this._defaultHeaders, customHeaders);
            this.assertAccessTokenIsSet();
            return new Promise((resolve, reject) => {
                this.oauthLib.put(this.config.apiBaseUrl + this.config.apiBasePath + endpoint, // url
                this._state.oauth_token, this._state.oauth_token_secret, JSON.stringify(body), // Had to do this not sure if there is another way
                'application/json', (err, data, httpResponse) => {
                    // data is the body of the response
                    if (err) {
                        reject(err.statusCode ? new XeroError_1.XeroError(err.statusCode, err.data, httpResponse ? httpResponse.headers : null) : err);
                    }
                    else {
                        const toReturn = JSON.parse(data);
                        return resolve(toReturn);
                    }
                });
            });
        });
        this.post = (endpoint, body, customHeaders) => __awaiter(this, void 0, void 0, function* () {
            this.resetToDefaultHeaders();
            this.oauthLib._headers = Object.assign({}, this._defaultHeaders, customHeaders);
            this.assertAccessTokenIsSet();
            return new Promise((resolve, reject) => {
                this.oauthLib.post(this.config.apiBaseUrl + this.config.apiBasePath + endpoint, // url
                this._state.oauth_token, this._state.oauth_token_secret, JSON.stringify(body), // Had to do this not sure if there is another way
                'application/json', (err, data, httpResponse) => {
                    // data is the body of the response
                    if (err) {
                        reject(err.statusCode ? new XeroError_1.XeroError(err.statusCode, err.data, httpResponse ? httpResponse.headers : null) : err);
                    }
                    else {
                        let toReturn = null;
                        if (data) {
                            toReturn = JSON.parse(data);
                        }
                        return resolve(toReturn);
                    }
                });
            });
        });
        this.patch = (endpoint, body, customHeaders) => __awaiter(this, void 0, void 0, function* () {
            this.resetToDefaultHeaders();
            this.oauthLib._headers = Object.assign({}, this._defaultHeaders, customHeaders);
            this.assertAccessTokenIsSet();
            return new Promise((resolve, reject) => {
                this.oauthLib.patch(this.config.apiBaseUrl + this.config.apiBasePath + endpoint, // url
                this._state.oauth_token, this._state.oauth_token_secret, JSON.stringify(body), // Had to do this not sure if there is another way
                'application/json', (err, data, httpResponse) => {
                    // data is the body of the response
                    if (err) {
                        reject(err.statusCode ? new XeroError_1.XeroError(err.statusCode, err.data, httpResponse ? httpResponse.headers : null) : err);
                    }
                    else {
                        const toReturn = JSON.parse(data);
                        return resolve(toReturn);
                    }
                });
            });
        });
        this.delete = (endpoint, customHeaders) => __awaiter(this, void 0, void 0, function* () {
            this.resetToDefaultHeaders();
            this.oauthLib._headers = Object.assign({}, this._defaultHeaders, customHeaders);
            this.assertAccessTokenIsSet();
            return new Promise((resolve, reject) => {
                this.oauthLib.delete(this.config.apiBaseUrl + this.config.apiBasePath + endpoint, // url
                this._state.oauth_token, this._state.oauth_token_secret, (err, data, httpResponse) => {
                    // data is the body of the response
                    if (err) {
                        reject(err.statusCode ? new XeroError_1.XeroError(err.statusCode, err.data, httpResponse ? httpResponse.headers : null) : err);
                    }
                    else {
                        let toReturn = null;
                        if (data) {
                            toReturn = JSON.parse(data);
                        }
                        return resolve(toReturn);
                    }
                });
            });
        });
        if (authState) {
            this._state = authState;
        }
        if (!this.oAuthLibFactory) {
            this.oAuthLibFactory = function (passedInConfig) {
                let requestTokenPath = passedInConfig.oauthRequestTokenPath;
                if (passedInConfig.tenantType) {
                    requestTokenPath += `?tenantType=${passedInConfig.tenantType}`;
                }
                return new oauth_1.OAuth(passedInConfig.apiBaseUrl + requestTokenPath, // requestTokenUrl
                passedInConfig.apiBaseUrl + passedInConfig.oauthAccessTokenPath, // accessTokenUrl
                passedInConfig.consumerKey, // consumerKey
                passedInConfig.consumerSecret, // consumerSecret
                '1.0A', // version
                config.callbackUrl, // authorize_callback
                passedInConfig.signatureMethod, // signatureMethod. Neesds to ve "RSA-SHA1" for Private. "HMAC-SHA1" for public
                null, // nonceSize
                {
                    'Accept': passedInConfig.accept,
                    'User-Agent': passedInConfig.userAgent
                });
            };
        }
        this.oauthLib = this.oAuthLibFactory(this.config);
        this.oauthLib._createClient = this._createHttpClientWithProxySupport.bind(this);
    }
    resetToDefaultHeaders() {
        this.oauthLib._headers = this._defaultHeaders;
    }
    setState(newState) {
        this._state = Object.assign({}, this._state, newState);
    }
    assertAccessTokenIsSet() {
        if (!this._state.oauth_token) {
            throw new Error('Missing access token. Acquire a new access token by following the oauth flow or call setState() to use an existing token.');
        }
    }
    // Monkey-patched OAuthLib _createClient function to add proxy support
    _createHttpClientWithProxySupport(port, hostname, method, path, headers, sslEnabled) {
        const options = {
            host: hostname,
            port: port,
            path: path,
            method: method,
            headers: headers
        };
        const httpModel = sslEnabled ? https : http;
        if (this.agent) {
            options.agent = this.agent;
        }
        return httpModel.request(options);
    }
}
exports.OAuth1HttpClient = OAuth1HttpClient;
//# sourceMappingURL=OAuth1HttpClient.js.map